
options {
    STATIC = false;
    LOOKAHEAD = 2;
    FORCE_LA_CHECK = false;
    DEBUG_PARSER = true;
    CHOICE_AMBIGUITY_CHECK = 3;
}

PARSER_BEGIN(SourceParser)
    package st.redline.compiler;
    class SourceParser implements Parser {
        private ParsedSource parsedSource = new ParsedSource();
        public void sourcePath(String sourcePath) {
            parsedSource.sourcePath(sourcePath);
        }
        public void outputPath(String outputPath) {
            parsedSource.outputPath(outputPath);
        }
        public boolean isDefinedVariable(Token token) {
            return parsedSource.isDefinedVariable(token);
        }
        public void defineVariable(Token token) {
            parsedSource.defineVariable(token);
        }
        public void defineVariables(Token token) {
            parsedSource.defineVariables(token);
        }
        public void enterMethodContext() {
            parsedSource.enterMethodContext();
        }
        public void exitMethodContext() {
            parsedSource.exitMethodContext();
        }
    }
PARSER_END(SourceParser)

SKIP : {
    " " | "\t" | "\n" | "\r" | <"\"">: INSIDE_COMMENT
}

<INSIDE_COMMENT>
SKIP: {
    <"\"">: DEFAULT | <~[]>
}

TOKEN : {
    < PERIOD: "." >
|   < ASSIGNMENT: ":=" | "_" >
|   < DOUBLE_BANG: "! !" >
|   < SINGLE_BANG: "!" >
|   < CHARACTER: "$" (["a"-"z","A"-"Z","0"-"9","~","!","@","%","&","*","-","+","=","\\","|","?","/",">","<",",","_","^","#","(",")","[","]",":",";","{","}","'","\""]){1} >
|   < NAME: ["a"-"z", "A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
|   < STRING: "'" (~["'"])* "'">
|   < DECIMAL_NUMBER: (["0"-"9"])+ ("." (["0"-"9"])+)? >
|   < RADIX_NUMBER: (["0"-"9"])+ "r" (["0"-"9","A"-"Z"])+ ("." (["0"-"9","A"-"Z"])+)? >
|   < SCALED_NUMBER: <DECIMAL_NUMBER> "s" (["0"-"9"])+ >
|   < EXPONENT_NUMBER: (<DECIMAL_NUMBER> | <RADIX_NUMBER>) "e" ("-")? (["0"-"9"])+ >
|   < BINARY_SYMBOL: ["~","!","@","%","&","*","-","+","=","\\","?","/",">","<",","] (["~","!","@","%","&","*","-","+","=","\\","?","/",">","<",","])* >
|   < KEYWORD: <NAME> ":" >
|   < MULTI_KEYWORD: <NAME> ":" (<NAME> ":")+ >
|   < ALTERNATE_KEYWORD: ":" <NAME> ":" (<NAME> ":")* >
|   < RIGHT_PARENTHESIS: ")" >
|   < RIGHT_CURLY_BRACKET: "}" >
|   < RIGHT_BOX_BRACKET: "]" >
|   < SEMICOLON: ";" >
}

Object parse():
{}
{
    program(parsedSource)
    <EOF>
    { return parsedSource; }
}

void program(ParsedSource parsedSource):
{ Sequence sequence; }
{
    LOOKAHEAD({
        getToken(1).kind == NAME && Character.isUpperCase(getToken(1).image.charAt(0))
        && getToken(2).kind == KEYWORD && getToken(2).image.equals("subclass:")
    })
    classDefinition(parsedSource)
    (
       (
           LOOKAHEAD(<SINGLE_BANG><NAME>)
           methodCommentStamps(parsedSource)
       )?
       method(parsedSource)
    )*
    |
    sequence = sequence()
    { parsedSource.add(sequence); }
}

void classDefinition(ParsedSource parsedSource):
{ Token superclass; Token subclass; Token instanceVariableNames; Token classVariableNames; Token poolDictionaries; Token category; }
{
        superclass = <NAME>
        expectedKeyword("subclass:")"#" subclass = <NAME>
        expectedKeyword("instanceVariableNames:") instanceVariableNames = <STRING>
        expectedKeyword("classVariableNames:") classVariableNames = <STRING>
        expectedKeyword("poolDictionaries:") poolDictionaries = <STRING>
        expectedKeyword("category:") category = <STRING>
        <SINGLE_BANG>
    (
        LOOKAHEAD("!"<NAME><KEYWORD>)
        classCommentStamp(parsedSource)
    )?
    {
        defineVariables(instanceVariableNames);
        defineVariables(classVariableNames);     // TODO. class variables should probably be in different map to instance variables.
        defineVariables(poolDictionaries);
        parsedSource.add(new ClassDefinition(superclass, subclass, instanceVariableNames, classVariableNames, poolDictionaries, category)); }
}

void expectedKeyword(String expected):
{ Token keyword; }
{
    keyword = <KEYWORD>
    { if (!keyword.toString().equals(expected)) throw generateParseException(); }
}

void expectedBinarySymbol(String expected):
{ Token binarySymbol; }
{
    binarySymbol = <BINARY_SYMBOL>
    { if (!binarySymbol.toString().equals(expected)) throw generateParseException(); }
}

void classCommentStamp(ParsedSource parsedSource):
{ Token subclass; Token comment; Token classComment; Number version; }
{
    <SINGLE_BANG> subclass = <NAME> expectedKeyword("commentStamp:") comment = <STRING> expectedKeyword("prior:") version = number() <SINGLE_BANG>
    { parsedSource.add(new ClassComment(subclass, comment, version)); }
}

void methodCommentStamps(ParsedSource parsedSource):
{ Token comment; }
{
    methodCommentStamp(parsedSource)
    (
        methodCommentStamp(parsedSource)
    )*
}

void methodCommentStamp(ParsedSource parsedSource):
{ Token subclass; Token cls = null; Token comment; Token stamp = null; Token instanceVars = null; }
{
    <SINGLE_BANG> subclass = <NAME> (cls = <NAME>)? (instanceVars = <KEYWORD>) comment = <STRING> (expectedKeyword("stamp:") stamp = <STRING>)? <SINGLE_BANG>
    {
        if (cls != null)
            if (instanceVars != null && instanceVars.toString().equals("instanceVariableNames:"))
                parsedSource.add(new ClassInstanceVariables(subclass, comment));
            else
                parsedSource.add(new ClassMethodComment(subclass, comment, stamp));
        else
            parsedSource.add(new InstanceMethodComment(subclass, comment, stamp));
    }
}

void method(ParsedSource parsedSource):
{
    MethodPattern methodPattern = null; Sequence sequence; Pragmas pragmas = null;
    enterMethodContext();
}
{
    methodPattern = methodPattern()
    (pragmas = pragmas())?
    sequence = sequence()
    {
        parsedSource.add(new Method(methodPattern, pragmas, sequence));
        exitMethodContext();
    }
}

Sequence sequence():
{ Statements statements = null; Temporaries temporaries = null; Pragmas pragmas = null; }
{
    <DOUBLE_BANG>
    { return new EmptySequence(); }
    |
    (
        (temporaries = temporaries())?
        (pragmas = pragmas())?
        statements = statements() <DOUBLE_BANG>
    )
    { return new Sequence(pragmas, temporaries, statements); }
}

Statements statements():
{ StatementList statementList; Expression expression; }
{
    (statementList = statementList()
    (
        <PERIOD> "^" expression = expression()
        {
            expression.isAnswered(true);
            statementList.add(expression);
        }
    )?
    (<PERIOD>)?)
    { return new Statements(statementList); }
    |
    ("^" expression = expression() (<PERIOD>)?)
    {
        expression.isAnswered(true);
        return new Statements(new StatementList(expression));
    }
}

StatementList statementList():
{ StatementList statementList; Expression expression; }
{
    expression = expression()
    { statementList = new StatementList(expression); }
    (
        <PERIOD> expression = expression()
        { statementList.add(expression); }
    )*
    { return statementList; }

}

Expression expression():
{ Assignment assignment; Primary primary; Cascade cascade; }
{
    LOOKAHEAD({
        getToken(1).kind == NAME && isDefinedVariable(getToken(1))
        && getToken(2).kind == ASSIGNMENT
    })
    assignment = assignment()
    { return new Expression(assignment); }
    |
    primary = primary()
    { return new Expression(primary); }
//    |
//    cascade = cascade()
//    { return new Expression(cascade); }
}

Assignment assignment():
{ Variable variable; Expression expression; }
{
    variable = variable() <ASSIGNMENT> expression = expression()
    { return new Assignment(variable, expression); }
}

Primary primary():
{ Expression expression; Variable variable; Literal literal; Array array; Block block; }
{
    "(" expression = expression() <RIGHT_PARENTHESIS>
    { return new Primary(expression); }
    |
    LOOKAHEAD("{")
    array = array()
    { return new Primary(array); }
    |
    LOOKAHEAD("[")
    block = block()
    { return new Primary(block); }
    |
    literal = literal()
    { return new Primary(literal); }
    |
    LOOKAHEAD( {getToken(1).kind == NAME && isDefinedVariable(getToken(1))} )
    variable = variable()
    { return new Primary(variable); }
}

Block block():
{ BlockArgs blockArgs = new BlockArgs(); Sequence sequence = null; Variable variable; }
{
    "["
    (
        (":" variable = variable())*
        ("|")?
    )
    <RIGHT_BOX_BRACKET>
    { return null; }
}

void blockTemporary(BlockArgs blockArgs):
{ Variable variable; }
{
	":" variable = variable()
	{ blockArgs.add(variable); }
}

Literal literal():
{ Token token; Number number; LiteralArray literalArray; }
{
    LOOKAHEAD( {getToken(1).kind == NAME && "true false nil".indexOf(getToken(1).toString()) != -1} )
    token = <NAME>
    { return new SpecialLiteral(token); }
    |
    number = number()
    { return new NumberLiteral(number); }
    |
    LOOKAHEAD( {getToken(1).kind == BINARY_SYMBOL && getToken(1).toString() == "-"} )
    <BINARY_SYMBOL> number = number()
    { return new NegativeNumberLiteral(number); }
    |
    token = <CHARACTER>
    { return new CharacterLiteral(token); }
    |
    token = <STRING>
    { return new StringLiteral(token); }
    |
    "#"
    (
        token = <STRING>
        { return new StringLiteralSymbol(token); }
        |
        (token = <NAME> | token = <BINARY_SYMBOL> | token = <KEYWORD> | token = <MULTI_KEYWORD> | token = <ALTERNATE_KEYWORD>)
        { return new LiteralSymbol(token); }
        |
        "(" literalArray = literalArray() <RIGHT_PARENTHESIS>
        { return literalArray; }
        |
        token = ":"
        { return new StringLiteral(token); }

        // TODO.
        //  > |	""#"" ""["" ByteArray <rightBoxBrackets>			{#litArray:}
    )
}

LiteralArray literalArray():
{ LiteralArray literalArray; ArrayLiteral arrayLiteral; }
{
    arrayLiteral = arrayLiteral()
    { literalArray = new LiteralArray(arrayLiteral); }
    (
        arrayLiteral = arrayLiteral()
        { literalArray.add(arrayLiteral); }
    )*
    { return literalArray; }
}

ArrayLiteral arrayLiteral():
{ Literal literal; LiteralArray literalArray; Token token; }
{
    literal = literal()
    { return new ArrayLiteral(literal); }
    |
    (token = <NAME> | token = <BINARY_SYMBOL> | token = <KEYWORD> | token = <ALTERNATE_KEYWORD>)
    { return new ArrayLiteral(token); }
    |
    "(" literalArray = literalArray() <RIGHT_PARENTHESIS>
    { return new ArrayLiteral(literalArray); }

    // TODO.
    // > |	""["" ByteArray <rightBoxBrackets>				{#contents2:}
    // > |	<anyChar>									{#valueSymbol:};
}

Array array():
{ Statements statements; }
{
    "{" statements = statements() <RIGHT_CURLY_BRACKET>
    { return new st.redline.compiler.Array(statements); }
}

MethodPattern methodPattern():
{ Token name; Token binarySymbol; Variable variable; KeywordMethodPattern keywordMethodPattern; }
{
    name = <NAME>
    { return new UnaryMethodPattern(name); }
    |
    binarySymbol = <BINARY_SYMBOL> variable = undefinedVariable()
    { return new BinaryMethodPattern(binarySymbol, variable); }
    |
    keywordMethodPattern = keywordMethodPattern()
    { return keywordMethodPattern; }
}

KeywordMethodPattern keywordMethodPattern():
{ Token keyword; Variable variable; KeywordMethodPattern keywordMethodPattern; }
{
    keyword = <KEYWORD> variable = undefinedVariable()
    { keywordMethodPattern = new KeywordMethodPattern(keyword, variable); }
    (
        keyword = <KEYWORD> variable = undefinedVariable()
        { keywordMethodPattern.add(new KeywordMethodPattern(keyword, variable)); }
    )*
    { return keywordMethodPattern; }
}

Variable undefinedVariable():
{ Token name; }
{
    name = <NAME>
    {
        if (isDefinedVariable(name))
            throw generateParseException();
        defineVariable(name);
       return new Variable(name);
    }
}

Variable variable():
{ Token name; }
{
    name = <NAME>
    {
        if (!isDefinedVariable(name))
            throw generateParseException();
        return new Variable(name);
    }
}

Number number():
{ Token number; }
{
    (
        number = <DECIMAL_NUMBER>
        { return new DecimalNumber(number); }
      | number = <RADIX_NUMBER>
        { return new RadixNumber(number); }
      | number = <EXPONENT_NUMBER>
        { return new ExponentNumber(number); }
      | number = <SCALED_NUMBER>
        { return new ScaledNumber(number); }
    )
}

Temporaries temporaries():
{ Temporaries temporaries = new Temporaries(); Variable variable = null; }
{
    (
        "|" ( variable = undefinedVariable() )* "|"
        { temporaries.add(variable); }
    )
    { return temporaries; }
}

Pragmas pragmas():
{ Pragmas pragmas; PragmaMessage pragmaMessage; }
{
    LOOKAHEAD( {getToken(1).kind == BINARY_SYMBOL && getToken(1).image.equals("<")} )
    expectedBinarySymbol("<")
    (
        pragmaMessage = pragmaMessage() expectedBinarySymbol(">")
        { pragmas = new Pragmas(pragmaMessage); }
        (
            expectedBinarySymbol("<") pragmaMessage = pragmaMessage() expectedBinarySymbol(">")
            { pragmas.add(pragmaMessage); }
        )*
    )
    { return pragmas; }
}

PragmaMessage pragmaMessage():
{ Primitive primitive; }
{
    primitive = primitive()
    { return new PragmaMessage(primitive); }
    // There are other pragmaMessage, but I haven't handled them yet.
}

Primitive primitive():
{ Number number; Token string; Token module; }
{
    LOOKAHEAD( {getToken(1).kind == KEYWORD && getToken(1).image.equals("primitive:")} )
    expectedKeyword("primitive:")
    (
        (
            string = <STRING>
            (
                expectedKeyword("module:") module = <STRING>
                { return new Primitive(string, module); }
            )?
            { return new Primitive(string); }
        )
        |
        number = number()
        { return new Primitive(number); }
    )
}
