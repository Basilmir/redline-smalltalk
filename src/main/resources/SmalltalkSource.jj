
options {
    STATIC = false;
    LOOKAHEAD = 2;
    FORCE_LA_CHECK = true;
    DEBUG_PARSER = true;
    CHOICE_AMBIGUITY_CHECK = 3;
    USER_CHAR_STREAM = false;
}

PARSER_BEGIN(SourceParser)
    package st.redline.compiler;
    import java.util.*;
    class SourceParser implements Parser {
        private ParsedSource parsedSource = new ParsedSource();
        public void sourcePath(String sourcePath) {
            parsedSource.sourcePath(sourcePath);
        }
        public void outputPath(String outputPath) {
            parsedSource.outputPath(outputPath);
        }
        public boolean isDefinedVariable(Token token) {
            return parsedSource.isDefinedVariable(token);
        }
        public boolean isDefinedClass(Token token) {
            return parsedSource.isDefinedClass(token);
        }
        public boolean isDefinedEnvironment(Token token) {
            return parsedSource.isDefinedEnvironment(token);
        }
        public void defineVariable(Token token) {
            parsedSource.defineVariable(token);
        }
        public void defineVariables(Token token) {
            parsedSource.defineVariables(token);
        }
        public void enterMethodContext() {
            parsedSource.enterMethodContext();
        }
        public void exitMethodContext() {
            parsedSource.exitMethodContext();
        }
        public void enterBlockContext() {
            parsedSource.enterBlockContext();
        }
        public void exitBlockContext() {
            parsedSource.exitBlockContext();
        }
    }
PARSER_END(SourceParser)

SKIP : {
    " " | "\t" | "\n" | "\r" | <"\"">: INSIDE_COMMENT
}

<INSIDE_COMMENT> SKIP: {
    <"\"">: DEFAULT | <~[]>
}

TOKEN: {
    < END_SCRIPT: "! !" | ".! !" >  
|   < BANG: "!">
|   < ANSWER: "^">
|   < ASSIGNMENT: ":=" | "_" >
|   < NIL: "nil" >
|   < TRUE: "true" >
|   < FALSE: "false" >
|   < SELF: "self" >
|   < SUPER: "super" >
|   < HASH: "#" >
|   < DECIMAL_NUMBER: (["0"-"9"])+ ("." (["0"-"9"])+)? >
|   < RADIX_NUMBER: (["0"-"9"])+ "r" (["0"-"9","A"-"Z"])+ ("." (["0"-"9","A"-"Z"])+)? >
|   < SCALED_NUMBER: <DECIMAL_NUMBER> "s" (["0"-"9"])+ >
|   < EXPONENT_NUMBER: (<DECIMAL_NUMBER> | <RADIX_NUMBER>) "e" ("-")? (["0"-"9"])+ >
|   < IDENTIFIER: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
|   < BINARY_SYMBOL: ["~","@","%","&","*","-","+","=","\\","?","/","<",">",","] (["~","@","%","&","*","-","+","=","\\","?","/","<",">",","])* >
|   < KEYWORD: <IDENTIFIER> ":" >
|   < PIPE: "|" >
|   < PERIOD: "." >
|   < LEFT_PARENTHESES: "(" >
|   < RIGHT_PARENTHESES: ")" >
|   < CHARACTER: "$" (["a"-"z","A"-"Z","0"-"9","~","!","@","%","&","*","-","+","=","\\","|","?","/",">","<",",","_","^","#","(",")","[","]",":",";","{","}","'","\""]){1} >
|   < STRING: "'" ( "'" "'" | (~["'"])* )* "'" > 
|   < MULTI_KEYWORD: <IDENTIFIER> ":" (<IDENTIFIER> ":")+ >
|   < ALTERNATE_KEYWORD: ":" <IDENTIFIER> ":" (<IDENTIFIER> ":")* >
|   < COLON: ":" >
|   < SEMICOLON: ";" >
|   < LEFT_CURLY_BRACKET: "{" >
|   < RIGHT_CURLY_BRACKET: "}" >
|   < LEFT_SQUARE_BRACKET: "[" >
|   < RIGHT_SQUARE_BRACKET: "]" >
}

Object parse():
{}
{
    parseSource()
    <EOF>
    { return parsedSource; }
}

void parseSource():
{}
{
    parseClass()
    // |
    // parseScript()
}

void parseClass():
{}
{
    (pharoFileOutComment())?
    classDefinition()
    (method())*
}

void pharoFileOutComment():
{}
{
    <STRING><BANG>
}

void classDefinition():
{ ClassDefinition classDefinition; UnarySend unarySend; KeywordSend keywordSend; }
{
    unarySend = unarySend()
    { classDefinition = new ClassDefinition(unarySend); }
    (
        LOOKAHEAD(<KEYWORD>) keywordSend = keywordSend()
        { classDefinition.add(keywordSend); }
    )*
    <BANG>
    { parsedSource.add(classDefinition); }
}

void keyword(String expected):
{ Token keyword; }
{
    keyword = <KEYWORD>
    { if (!keyword.toString().equals(expected)) throw new RuntimeException("Keyword '"+expected+"' was expected. Error on line: " + keyword.beginLine); }
}

String specifier(String first, String second, String third):
{ Token keyword; }
{
    keyword = <KEYWORD>
    {
        if (keyword.toString().equals(first))
            return first;
        if (keyword.toString().equals(second))
            return second;
        if (keyword.toString().equals(third))
            return third;
        throw new RuntimeException("Keyword '"+first+"' or '"+second+"' or '"+third+"' was expected. Error on line: " + keyword.beginLine);
    }
}

void classDefinitionStamp():
{ Token subclass; Token comment; Token prior; }
{
    <BANG> subclass = <IDENTIFIER> keyword("commentStamp:") comment = <STRING> keyword("prior:") prior = <DECIMAL_NUMBER> <BANG>
    { parsedSource.add(new ClassComment(subclass, comment, prior)); }
}

void methodComment():
{ Token subclass; Token comment; Token version = null; Token cls = null; String specifier; Token bang; }
{
    bang = <BANG> subclass = <IDENTIFIER> (cls = <IDENTIFIER>)? specifier = specifier("methodsFor:", "instanceVariableNames:", "commentStamp:") comment = <STRING> (specifier("stamp:", "prior:", "") (version = <STRING> | version = <DECIMAL_NUMBER>))? <BANG>
    {
        if (specifier.equals("methodsFor:"))
            parsedSource.add(new MethodComment(subclass, (cls != null), comment, version));
        else if (specifier.equals("instanceVariableNames:"))
            parsedSource.add(new ClassInstanceVariables(subclass, comment));
        else {
            parsedSource.add(new ClassComment(subclass, comment, version));
        }
    }
}

void method():
{ enterMethodContext(); }
{
    (
        (methodComment())*
        messagePattern()
        sequence()
        {
            parsedSource.add(new Method());
            exitMethodContext();
        }
    )
}

void messagePattern():
{}
{
    (
        keywordMessagePattern()
        |
        binaryMessagePattern()
        |
        unaryMessagePattern()
    )
}

void keywordMessagePattern():
{ Token pattern; Variable methodArgument; KeywordMessagePattern keywordMessagePattern; }
{
    pattern = <KEYWORD> methodArgument = methodArgument()
    { keywordMessagePattern = new KeywordMessagePattern(pattern, methodArgument); }
    (
        pattern = <KEYWORD> methodArgument = methodArgument()
        { keywordMessagePattern.add(pattern, methodArgument); }
    )*
    { parsedSource.add(keywordMessagePattern); }
}

void unaryMessagePattern():
{ Token pattern; }
{
    pattern = <IDENTIFIER>
    { parsedSource.add(new UnaryMessagePattern(pattern)); }
}

void binaryMessagePattern():
{ Token pattern; Variable methodArgument; }
{
    (pattern = <BINARY_SYMBOL> | (pattern = <BANG>(<BANG>)?)) methodArgument = methodArgument()
    { parsedSource.add(new BinaryMessagePattern(pattern, methodArgument)); }
}

void parseScript():
{}
{
    sequence()
}

void sequence():
{ Statements statements; }
{
    (
        temporaries()
        (
            (
                statements = statements() <END_SCRIPT>
                { parsedSource.add(statements); }
            )
            |
            (
                pragmas(false) statements = statements() <END_SCRIPT>
                { parsedSource.add(statements); }
            )
        )
    )
    |
    (
        pragmas(true)
        (
            (
                temporaries()
                (
                    (
                        statements = statements() <END_SCRIPT>
                        { parsedSource.add(statements); }
                    )
                    |
                    (
                        pragmas(false) statements = statements() <END_SCRIPT>
                        { parsedSource.add(statements); }
                    )
                )
            )
            |
            (
                (
                    statements = statements() <END_SCRIPT>
                    { parsedSource.add(statements); }
                )
            )
        )
    )
    |
    (
        statements = statements() <END_SCRIPT>
        { parsedSource.add(statements); }
    )
    |
    <END_SCRIPT>
}

Statements statements():
{ Expression expression; Statements statements = new Statements(); Statements statementList; }
{
    (
        (
            <ANSWER> expression = expression(true)
            { statements.add(expression); }
        )
        |
        (
            statementList = statementList()
            (
                <PERIOD> <ANSWER> expression = expression(true)
                { statementList.add(expression); }
            )?
            { statements.add(statementList); }
        )
    )
    (<PERIOD>)? 
    { return statements; }
}

Statements statementList():
{ Expression expression; Statements statements = new Statements(); }
{
    expression = expression(false)
    { statements.add(expression); }
    (
        <PERIOD> expression = expression(false)
        { statements.add(expression); }
    )*
    { return statements; }
}

Expression expression(boolean isAnswered):
{ Expression expression; Primary primary; Cascade cascade; }
{
    LOOKAHEAD(<IDENTIFIER><ASSIGNMENT>)
    expression = assignment(isAnswered)
    { return expression; }
    |
    LOOKAHEAD({ getToken(2).kind != ASSIGNMENT })
    cascade = cascade()
    { return new Expression(isAnswered, cascade); }
}

Cascade cascade():
{ Cascade cascade; }
{
    unarySend()

    (LOOKAHEAD(<BINARY_SYMBOL>) binarySend() )*

    (LOOKAHEAD(<KEYWORD>) keywordSend() )*

    (
        LOOKAHEAD(<SEMICOLON>)
        <SEMICOLON>
        (
          LOOKAHEAD(<IDENTIFIER>)
          unarySelector()
        |
          LOOKAHEAD(<BINARY_SYMBOL>)
          binarySend()
        |
          LOOKAHEAD(<KEYWORD>)
          (keywordSend())*
        )
    )*
    { return null; }
}

BinarySend binarySend():
{ UnarySend unarySend; Token binarySymbol; }
{
    binarySymbol = <BINARY_SYMBOL> unarySend = unarySend()
    { return new BinarySend(binarySymbol, unarySend); }
}

KeywordSend keywordSend():
{ KeywordSend keywordSend; Token keyword; UnarySend unarySend; BinarySend binarySend; }
{
    keyword = <KEYWORD>
    { keywordSend = new KeywordSend(keyword); }
    unarySend = unarySend()
    { keywordSend.add(unarySend); }
    (
        LOOKAHEAD(<BINARY_SYMBOL>) binarySend = binarySend()
        { keywordSend.add(binarySend); }
    )*
    { return keywordSend; }
}

UnarySend unarySend():
{ UnarySend unarySend; Primary primary; Token unarySelector; }
{
    primary = primary()
    { unarySend = new UnarySend(primary); }
    (
        LOOKAHEAD(<IDENTIFIER>) unarySelector = unarySelector()
        { unarySend.add(unarySelector); }
    )*
    { return unarySend; }
}

Token unarySelector():
{ Token selector; }
{
    selector = <IDENTIFIER>
    { return selector; }
}

Expression assignment(boolean isAnswered):
{ Variable variable; Expression expression; }
{
    variable = variable() <ASSIGNMENT> expression = expression(false)
    { return new AssignmentExpression(isAnswered, variable, expression); }
}

Primary primary():
{ Expression expression; Variable variable; Literal literal; StatementsArray array; Block block; }
{
    (
        <LEFT_PARENTHESES> expression = expression(false) <RIGHT_PARENTHESES>
        { return new PrimaryExpression(expression); }
    )
    |
    LOOKAHEAD(<LEFT_SQUARE_BRACKET>)
    (
        block = block()
        { return new PrimaryBlock(block); }
    )
    |
    LOOKAHEAD(<LEFT_CURLY_BRACKET>)
    (
        array = array()
        { return new PrimaryArray(array); }
    )
    |
    (
        variable = variable()
        { return new PrimaryVariable(variable); }
    )
    |
    (
        literal = literal()
        { return new PrimaryLiteral(literal); }
    )
}

StatementsArray array():
{ Statements statements; }
{
    <LEFT_CURLY_BRACKET> statements = statements() <RIGHT_CURLY_BRACKET>
    { return new StatementsArray(statements); }
}

Literal literal():
{ Token token; Number number; LiteralArray literalArray = null; StringLiteral stringLiteral; }
{
    (
        (token = <NIL> | token = <TRUE> | token = <FALSE> | token = <SELF> | token = <SUPER>)
        { return new SpecialLiteral(token); }
    )
    |
    number = number()
    { return new NumberLiteral(number); }
    |
    token = <CHARACTER>
    { return new CharacterLiteral(token); }
    |
    token = <STRING>
    { return new StringLiteral(token); }
    |
    <HASH>
    (
        token = <STRING>
        { return new StringSymbolLiteral(token); }
        |
        token = <IDENTIFIER>
        { return new SymbolLiteral(token); }
        |
        token = <BINARY_SYMBOL>
        { return new BinarySymbolLiteral(token); }
        |
        token = <KEYWORD>
        { return new KeywordSymbolLiteral(token); }
        |
        token = <MULTI_KEYWORD>
        { return new KeywordSymbolLiteral(token); }
        |
        token = <ALTERNATE_KEYWORD>
        { return new AlternateKeywordSymbolLiteral(token); }
        |
        <LEFT_PARENTHESES> (literalArray = literalArray())? <RIGHT_PARENTHESES>
        { return new ArraySymbolLiteral(literalArray); }
        |
        token = <COLON>
        { return new StringSymbolLiteral(token); }
    )
}

LiteralArray literalArray():
{ LiteralArray literalArray; ArrayLiteral arrayLiteral; }
{
    arrayLiteral = arrayLiteral()
    { literalArray = new LiteralArray(arrayLiteral); }
    (
        arrayLiteral = arrayLiteral()
        { literalArray.add(arrayLiteral); }
    )*
    { return literalArray; }
}

ArrayLiteral arrayLiteral():
{ Literal literal; LiteralArray literalArray; Token token; }
{
    literal = literal()
    { return new ArrayLiteral(literal); }
    |
    (token = <IDENTIFIER> | token = <BINARY_SYMBOL> | token = <KEYWORD> | token = <ALTERNATE_KEYWORD>)
    { return new ArrayLiteral(token); }
    |
    <LEFT_PARENTHESES> literalArray = literalArray() <RIGHT_PARENTHESES>
    { return new ArrayLiteral(literalArray); }

    // TODO.
    // > |	""["" ByteArray <rightBoxBrackets>				{#contents2:}
    // > |	<anyChar>									{#valueSymbol:};
}

void temporaries():
{ List<Variable> variables = new ArrayList<Variable>(); Variable variable; }
{
    <PIPE>
    (
        variable = temporary()
        { variables.add(variable); }
    )*
    <PIPE>
    { parsedSource.add(variables); }
}

void pragmas(boolean first):
{ Primitive primitive; }
{
    binarySymbol("<") primitive = primitive() binarySymbol(">")
    { parsedSource.add(new Pragma(primitive), first); }
}

Primitive primitive():
{ Object firstPart; Token secondPart = null; }
{
    <KEYWORD> (firstPart = number() | firstPart = <STRING>) (<KEYWORD> secondPart = <STRING>)?
    {
        if (secondPart == null)
            return new Primitive(firstPart);
        return new Primitive(firstPart, secondPart);
    }
}

Variable methodArgument():
{ Token name; }
{
    name = <IDENTIFIER>
    {
        if (isDefinedVariable(name))
            throw new RuntimeException("Method argument '"+name+"' is already defined. Error on line: " + name.beginLine);
        defineVariable(name);
        return new Variable(name);
    }
}

void binarySymbol(String expected):
{ Token binarySymbol; }
{
    binarySymbol = <BINARY_SYMBOL>
    { if (!binarySymbol.toString().equals(expected)) throw new RuntimeException("BinarySymbol '"+expected+"' was expected. Error on line: " + binarySymbol.beginLine); }
}

Block block():
{
    Block block = new Block(); List<Variable> blockArguments; List<Variable> blockTemporaries; Statements statements;
    enterBlockContext(); 
}
{
    <LEFT_SQUARE_BRACKET>
    (
        (
            LOOKAHEAD(<COLON>)
            blockArguments = blockArguments()
            { block.addArguments(blockArguments); }
        )?
        (
            LOOKAHEAD(<PIPE>)
            blockTemporaries = blockTemporaries()
            { block.addTemporaries(blockTemporaries); }
        )?
        (
            statements = statements()
            { block.add(statements); }
        )?
    )
    <RIGHT_SQUARE_BRACKET>
    {
        exitBlockContext();
        return block;
    }
}

List<Variable> blockArguments():
{ List<Variable> arguments = new ArrayList<Variable>(); Variable argument; }
{
    <COLON> argument = temporary()
    { arguments.add(argument); }
    (
        (
            LOOKAHEAD(<COLON>)
            <COLON> argument = temporary()
            { arguments.add(argument); }
        )*
        <PIPE>
    )
    { return arguments; }
}

List<Variable> blockTemporaries():
{ List<Variable> temporaries = new ArrayList<Variable>(); Variable temporary; }
{
    LOOKAHEAD({ getToken(1).kind == PIPE && getToken(2).kind == IDENTIFIER && !isDefinedVariable(getToken(2)) })
    <PIPE> temporary = temporary()
    { temporaries.add(temporary); }
    (
        (
            temporary = temporary()
            { temporaries.add(temporary); }
        )*
        <PIPE>
    )
    { return temporaries; }
}

Number number():
{ Token number; Token minus = null; }
{
    number = <DECIMAL_NUMBER>
    { return new DecimalNumber(number, (minus != null)); }
    |
    number = <RADIX_NUMBER>
    { return new RadixNumber(number, (minus != null)); }
    |
    number = <EXPONENT_NUMBER>
    { return new ExponentNumber(number, (minus != null)); }
    |
    number = <SCALED_NUMBER>
    { return new ScaledNumber(number, (minus != null)); }
}

Variable temporary():
{ Token identifier; }
{
    identifier = <IDENTIFIER>
    {
        if (isDefinedVariable(identifier))
            throw new RuntimeException("Identifier '" + identifier + "' already defined as a variable. Error on line: " + identifier.beginLine);
        defineVariable(identifier);
        return new Variable(identifier, true);
    }
}

Variable variable():
{ Token identifier; Variable variable; }
{
    identifier = <IDENTIFIER>
    {
        variable = new Variable(identifier);

        if (isDefinedVariable(identifier))
            return variable;

        if (isDefinedClass(identifier)) {
            variable.isClass(true);
            return variable;
        }
        if (isDefinedEnvironment(identifier)) {
            variable.isEnvironment(true);
            return variable;
        }

        throw new RuntimeException("Identifier '" + identifier + "' expected to be defined as a variable, Class or Environment/Namespace. Error on line: " + identifier.beginLine);
    }
}
